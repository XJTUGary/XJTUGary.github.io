---
date: 2025-06-03
title: 如何排查死锁？实战诊断流程
categories:
  - SRE
  - 面经
draft: false
comments: true
---
你是否遇到过这样的场景：一个原本运行良好的Java应用，突然停止响应，请求超时，CPU使用率却可能不高？日志也仿佛时间静止，不再输出新的信息。这种“假死”状态背后，一个非常常见的罪魁祸首就是——**死锁（Deadlock）**。
<!-- more -->

当应用出现无响应、日志不更新等疑似死锁的症状时，可以按照以下步骤进行排查。

### **第1步：确定应用状态**

首先，登录到部署应用的服务器，使用 `jps` 或 `ps` 命令找到卡死的Java进程的PID（进程ID）。
```bash
jps -l
# 或者
ps -ef | grep java
```

### **第2步：获取线程快照（核心步骤）**

这是排查死锁最直接、最有效的方法。JDK自带了一个强大的命令行工具——`jstack`。

```bash
jstack -l <你的Java进程PID> > jstack_log.txt
```
这个命令会将当前Java进程的所有线程的执行状态（即线程快照）导出到一个文本文件中。

### **第3步：分析线程快照，寻找死锁证据**

用文本编辑器打开 `jstack_log.txt`，并直接搜索关键字 **`deadlock`**。`jstack` 工具非常智能，它会自动分析线程的依赖关系，并在日志的**最底部**清楚地告诉你发现了多少死锁，并详细列出每个死锁中涉及的线程和它们持有的锁资源。

你可能会看到类似这样的输出：

```
Found one Java-level deadlock:
=============================
"Thread-A":
  waiting to lock monitor 0x00007f88e1003980 (object 0x000000076ab66e58, a java.lang.Object),
  which is held by "Thread-B"
"Thread-B":
  waiting to lock monitor 0x00007f88e1003d80 (object 0x000000076ab66e68, a java.lang.Object),
  which is held by "Thread-A"

Java stack information for the threads listed above:
===================================================
"Thread-A":
        at com.example.DeadLockClass.methodA(DeadLockClass.java:20)
        - waiting to lock <0x000000076ab66e68> (a java.lang.Object)
        - locked <0x000000076ab66e58> (a java.lang.Object)
"Thread-B":
        at com.example.DeadLockClass.methodB(DeadLockClass.java:35)
        - waiting to lock <0x000000076ab66e58> (a java.lang.Object)
        - locked <0x000000076ab66e68> (a java.lang.Object)

Found 1 deadlock.
```

**解读一下：**

*   `Thread-A` 已经锁住了对象 `0x000000076ab66e58`，但同时它又在等待锁住对象 `0x000000076ab66e68`。
*   `Thread-B` 已经锁住了对象 `0x000000076ab66e68`，但同时它又在等待锁住对象 `0x000000076ab66e58`。
*   这就形成了一个完美的“循环等待”，死锁被确认了！


### **第4步：使用图形化工具（可选）**

除了命令行，你也可以使用图形化工具，它们对新手更友好。

*   **jconsole**： JDK自带，连接到目标进程后，在“线程”选项卡里有一个专门的“检测死锁”按钮，点击后会自动为你列出死锁的线程和资源。
*   **VisualVM**： 一个功能更强大的分析工具，同样可以检测死锁。

## **总结**

排查Java死锁问题的核心流程可以概括为：

1.  **`jps`** 找PID
2.  **`jstack -l <PID>`** 取快照
3.  在快照日志中搜索 **`deadlock`**，定位线程和代码行
4.  根据分析结果修复代码，并通过**统一加锁顺序**、**使用超时锁**等方法来预防。