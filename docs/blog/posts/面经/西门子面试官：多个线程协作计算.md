---
date: 2025-09-22
title: 西门子面试官：多个线程协作计算
categories:
  - 面经
  - 并发
draft: false
comments: true
---
请设计一个程序，包含四个线程：线程A、线程B：每5秒产生一个随机整数（1-100），线程C：等待A和B都产生数据后，计算A×B的乘积，线程D：等待C计算完成后，打印最终结果。
<!-- more -->

## 题目背景

**面试公司**：西门子医疗

**面试岗位**：服务端开发工程师（AI） 

**面试轮次**：技术二面  

**面试形式**：线下手写

## 题目描述

面试官给出了一个经典的多线程协作题目：

> "请设计一个程序，包含四个线程：

> - 线程A、线程B：每5秒产生一个随机整数（1-100）
> - 线程C：等待A和B都产生数据后，计算A×B的乘积
> - 线程D：等待C计算完成后，打印最终结果
> 
> 要求四个线程能够循环执行，保持正确的协作顺序。"

## 面试过程回顾

### 第一阶段：需求澄清（5分钟）

**我**："请问这个循环执行是指一轮结束后立即开始下一轮，还是需要等待5秒？"

**面试官**："很好的问题。A和B每5秒产生一个随机数，但整个流程的节奏应该由计算需求决定。一轮结束后可以立即开始下一轮，不需要额外等待。"

**我**："明白了。那么A和B的产生时间是否需要同步？比如是否要求它们同时产生？"

**面试官**："不要求严格同步，但要求C必须等待两个值都产生后才能计算。"

### 第二阶段：设计方案（10分钟）

我首先提出了三种可能的实现方案：

1. **CountDownLatch方案**：使用门闩机制控制执行顺序
2. **CyclicBarrier方案**：利用可重置的屏障
3. **wait/notify方案**：传统的线程间通信

**面试官**："为什么你最终选择了CountDownLatch？"

**我**："CountDownLatch更适合这种'等待多个事件完成'的场景。CyclicBarrier虽然可以重置，但更适合'多个线程相互等待'的情况。wait/notify需要手动管理状态，代码相对复杂。"

### 第三阶段：编码实现（15分钟）

我实现了基于CountDownLatch的解决方案：

```java
package Thread;


import java.util.Random;
import java.util.concurrent.CountDownLatch;

public class CountdownLatchDemo {
    private final Random random = new Random();
    private CountDownLatch abLatch;
    private CountDownLatch cLatch;
    private CountDownLatch dLatch;
    private volatile int a;
    private volatile int b;
    private volatile int c;

    private void resetLatch() {
        abLatch = new CountDownLatch(2);
        cLatch = new CountDownLatch(1);
        dLatch = new CountDownLatch(1);
    }

    class TaskA implements Runnable {
        @Override
        public void run() {
            while (true) {
                try {
                    Thread.sleep(5000);
                    a = random.nextInt(100) + 1;
                    System.out.println(Thread.currentThread().getName() + "Create a :" + a);
                    abLatch.countDown();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    class TaskB implements Runnable {
        @Override
        public void run() {
            while (true) {
                try {
                    Thread.sleep(5000);
                    b = random.nextInt(100) + 1;
                    System.out.println(Thread.currentThread().getName() + "Create b :" + b);
                    abLatch.countDown();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    class TaskC implements Runnable {
        @Override
        public void run() {
            while (true) {
                try {
                    abLatch.await();
                    c = a * b;
                    System.out.println(Thread.currentThread().getName() + "Computer the result :" + c);
                    cLatch.countDown();

                    //等待D打印完成后重置
                    dLatch.await();
                    resetLatch();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    class TaskD implements Runnable {
        @Override
        public void run() {
            while (true) {
                try {
                    cLatch.await();
                    System.out.println("Result is: " + c);
                    dLatch.countDown();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public void start() {
        Thread A = new Thread(new TaskA(), "Thread A");
        Thread B = new Thread(new TaskB(), "Thread B");
        Thread C = new Thread(new TaskC(), "Thread C");
        Thread D = new Thread(new TaskD(), "Thread D");

        A.start();
        B.start();
        C.start();
        D.start();
    }

    public CountdownLatchDemo () {
        resetLatch();
    }


    public static void main(String[] args) {
        new CountdownLatchDemo().start();
    }
}

```