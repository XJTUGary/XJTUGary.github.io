# 腾讯-全栈开发工程师面经

## 一面（技术面）

### 1. Node.js的事件驱动模型

Node.js采用事件驱动、非阻塞I/O模型，使其轻量且高效。核心组件包括：
- 事件循环（Event Loop）：负责处理异步操作
- 事件队列（Event Queue）：存储待处理的事件
- 观察者（Observers）：监听事件并触发回调
- 线程池：处理耗时的I/O操作

事件循环的六个阶段：
1. timers：执行setTimeout和setInterval的回调
2. I/O callbacks：执行I/O相关的回调
3. idle, prepare：内部使用
4. poll：获取新的I/O事件
5. check：执行setImmediate的回调
6. close callbacks：执行关闭事件的回调

### 2. Node.js中的异步错误处理

- 使用try/catch捕获同步错误
- 使用回调函数的第一个参数传递错误
- 使用Promise的catch方法捕获异步错误
- 使用async/await结合try/catch捕获异步错误
- 使用process.on('uncaughtException')捕获未处理的异常
- 使用domain模块处理特定范围内的错误

### 3. RESTful API设计原则

- 资源导向：使用名词表示资源
- HTTP方法：使用GET、POST、PUT、DELETE等表示操作
- 状态码：使用合适的HTTP状态码表示响应状态
- 无状态：每个请求都是独立的，不依赖于之前的请求
- 过滤和分页：提供过滤、排序和分页功能
- 版本控制：支持API版本控制
- HATEOAS：提供链接到相关资源的信息

### 4. Express中间件实现

```javascript
// 记录请求日志的中间件
function loggerMiddleware(req, res, next) {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);
  next(); // 调用next()将控制权传递给下一个中间件
}

// 错误处理中间件
function errorHandler(err, req, res, next) {
  console.error(err.stack);
  res.status(500).send('Something broke!');
}

// 使用中间件
app.use(loggerMiddleware);
app.use(errorHandler);
```

## 二面（技术面）

### 1. 分布式会话管理方案

- 基于Cookie：将用户信息加密后存储在Cookie中
- 基于Redis：将会话信息存储在Redis中，使用Session ID关联
- 基于JWT：使用JSON Web Token进行无状态认证
- 基于数据库：将会话信息存储在数据库中

JWT实现示例：
```javascript
const jwt = require('jsonwebtoken');

// 生成token
const token = jwt.sign({ userId: '123' }, 'secretKey', { expiresIn: '1h' });

// 验证token
jwt.verify(token, 'secretKey', (err, decoded) => {
  if (err) return res.status(401).send('Invalid token');
  req.userId = decoded.userId;
  next();
});
```

### 2. 数据库查询性能优化

- 建立索引：为频繁查询的字段建立索引
- 优化查询语句：避免使用SELECT *，减少JOIN操作
- 分页查询：使用LIMIT和OFFSET进行分页
- 缓存结果：使用Redis等缓存热点数据
- 数据库分区：水平分区或垂直分区
- 慢查询优化：分析慢查询日志，优化查询计划
- 连接池：使用连接池管理数据库连接

### 3. Docker和Kubernetes的用途

Docker：
- 容器化：将应用及其依赖打包成容器
- 标准化：保证环境一致性
- 轻量级：共享宿主机内核，资源占用少
- 隔离性：进程级别隔离

Kubernetes：
- 容器编排：管理容器的部署、扩展和滚动更新
- 服务发现：自动发现和负载均衡
- 自愈能力：自动重启失败的容器
- 水平扩展：根据负载自动扩缩容
- 配置管理：集中管理应用配置

### 4. 二叉树的层序遍历

```javascript
function levelOrder(root) {
  if (!root) return [];
  const result = [];
  const queue = [root];

  while (queue.length > 0) {
    const levelSize = queue.length;
    const currentLevel = [];

    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      currentLevel.push(node.val);

      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }

    result.push(currentLevel);
  }

  return result;
}
```